# Homework assignments for the course "Advanced Python"

> Each homework is located in the folder - "HW_N", where N is the number of homework on the account.

## Homework 1

1. Написать упрощенный вариант утилиты `nl` -- скрипт, который выдает в `stdout` пронумерованные строки из файла. Если файл не передан, то скрипт читает строки из `stdin`. Он должен работать так же, как `nl -b a`.

2. Написать упрощенный вариант утилиты `tail` -- скрипт, выводящий в `stdout` последние 10 строк каждого из переданных файлов. Если передано больше одного файла, то перед обработкой очередного файла необходимо вывести его имя. Подробности смотрите в оригинальной утилите `tail`, ваш скрипт должен повторять форматирование. Если не передано ни одного файла, то нужно вывести последние 17 строк из `stdin`.

3. Написать скрипт, работающий так же, как утилита `wc`, вызванная без дополнительных опций. Т.е. для каждого переданного файла утилита выводит статистику (3 числа) и имя файла. При этом: если передано больше одного файла, то в самом конце утилита выводит суммарную статистику (total); если ни одного файла не передано, то утилита считывает весь вход и печатает для него статистику без имени.

## Homework 2

1. Написать функцию для генерации таблиц. На вход поступает двойной список, на выходе строка с отформатированным валидным латехом. Проверить, что латех валидный можно, например, в Overleaf. Используя другой модуль (.py файл) нужно импортировать вашу функцию и используя ее необходимо сохранить в .tex файл пример работы этой функции, это и будет артефактом для этой задачи. Если вы никогда не работали с латехом, то это хороший повод попробовать

2. Написать функцию для генерации картинок в латех. (В том же модуле, что и предыдущую функцию). В качестве картинки использовать любую картинку, НО: - Нужно собрать ваш код в библиотеку при помощи setuptools/conda-build, выложить в репозиторий - Установить вашу библиотеку. После этого, используя вашу библиотеку, сгенерировать по полученному латеху PDF с таблицей из задачи 2.1 и картинкой. PDF - первый артефакт задачи, ссылка на репозиторий в PyPI/Anaconda - второй. Генерировать pdf можно при помощи pdflatex. Но чтобы он заработал, нужен дистрибутив самого теха. Их много разных.

3. Скорее всего, для задачи 2.2 вы руками установили какие-то бинарные зависимости латеха. Если другой разработчик захочет переиспользовать ваш код, то ему придется проделать то же самое. Чтобы этого избежать, обычно используют Docker. Задача - написать Dockerfile и сгенерировать pdf при помощи докера. Артефактом будет сам Dockerfile, его можно оставить в папке hw02. Да, можно использовать docker compose.

## Homework 3

1. Сделать класс матрицы, в котором определить операции сложения и умножения (матричного и покомпонентного) через перегрузку операторов +, *, @ (как в numpy). Вызывать исключения, если матрицы на входе некорректной размерности (ValueError). Сгенерировать две матрицы через np.random.randint(0, 10, (10, 10)) c seed-ом 0 и над ними провести все три операции. Записать результаты в текстовые файлы, названные matrix+.txt, matrix*.txt, matrix@.txt, соответственно. Это будет артефактом задачи.

2. Используя примеси numpy, сделать класс, который будет уметь выполнять все стандартные арифметические операции. Также добавить через примеси: запись объекта в файл, красивое отображение в консоли (__str__), getter-ы и setter-ы для полей класса. В самих классах должно быть минимальное количество методов. Артефакты задачи - аналогично задаче 3.1

3. Задача является продолжением задачи 3.1. Придумать и реализовать простейшую хэш-функцию (дать краткое текстовое описание в комментариях в коде) для матрицы  в методе __hash__ (вынести в примесь). Ограничение на хэш-функцию - она должна быть не константой (не возвращать всегда одно число). Настроить кэширование произведения матриц по этой хэш-функции. Найти коллизию в хэш-функции (если поиск производится кодом, то код также нужно выложить). Артефакт - 7 файлов. A.txt, B.txt, C.txt, D.txt - матрицы, такие, что (hash(A) == hash(C)) and (A != C) and (B == D) and (A @ B != C @ D), AB.txt - результат произведения A @ B, CD.txt - настоящий результат произведения C @ D, hash.txt - хэш матриц AB и CD.

## Homework 4

1. Взять функцию подсчета чисел Фибоначчи и сравнить время исполнения кода (вызова функции от большого числа n (чтобы была видна разница в запусках на потоках и процессах) 10 раз, каждая на отдельном потоков\процессов) при использовании threading и multiprocessing. Запускаем одновременно 10 потоков/процессов, сравниваем общее время. Необходимо сравнить время выполнения при синхронном запуске, использовании потоков и процессов. Использовать concurrent.futures нельзя, задача про другое! Артефакт - текстовый файл с результатами запуска различными методами.

2. Переписать функцию integrate для того, чтобы ее выполнение можно было распараллелить. Использовать concurrent.futures: ThreadPoolExecutor и ProcessPoolExecutor.  Добавить логирование (когда какая задача запускается), сравнить время выполнения для integrate(math.cos, 0, math.pi / 2, n_jobs=n_jobs) при разном числе n_jobs (от 1 до cpu_num*2) при использовании ThreadPoolExecutor и ProcessPoolExecutor. Артефакт - файл логов, файл сравнения времени исполнения в обоих случаях в зависимости от числа воркеров.

3. Реализовать следующую схему приложения: У вас есть главный процесс и 2 дочерних (A и B). Из главного процесса вы можете через stdin отправлять сообщения (строки) в процесс A, которые будут складироваться в очередь. К каждому из сообщений процесс A будет применять .lower() и отправлять в процесс B (одно сообщение раз в 5 секунд). Процесс B должен отправлять закодированную строку через rot13, печатать в stdout и отправлять в отдельную очередь в главный процесс. Вам понадобится как минимум multiprocessing. Queue, а возможно и multiprocessing. Pipe и потоки. Артефакт - текстовый файл взаимодействия вас и программы (необходимо выводить время сообщений)

## Homework 5

1. Асинхронное скачивание картинок\файлов с любого сайта из https://thisxdoesnotexist.com/ или https://picsum.photos/ (лучше второй, так как этот сайт отдает вам каждый раз уникальные картинки, а не обновляет их раз в 1 секунду). Сделать питоновский скрипт, которому можно указать количество отличных друг от друга файлов, которые нужно загрузить в нужную папку. Использовать aiohttp.  Не забывайте, что следует не использовать блокирующий код при написании тасок для асинхронного выполнения.
